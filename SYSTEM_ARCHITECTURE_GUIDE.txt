================================================================================
                   TOO GOOD CRM - SYSTEM ARCHITECTURE GUIDE
                        Complete System Understanding
================================================================================

TABLE OF CONTENTS:
1. System Overview
2. Technology Stack
3. Architecture Pattern
4. Data Flow
5. Authentication & Security
6. Frontend Architecture
7. Backend Architecture
8. Database Schema
9. API Structure
10. Key Features
11. How Everything Works Together

================================================================================
1. SYSTEM OVERVIEW
================================================================================

Your CRM (Customer Relationship Management) system is a full-stack web application
that helps businesses manage:

âœ“ Customers (clients and accounts)
âœ“ Leads (potential customers)
âœ“ Deals (sales opportunities)
âœ“ Employees (team members)
âœ“ Vendors (suppliers)
âœ“ Organizations (multi-tenant support)
âœ“ Analytics (business metrics and reports)

The system supports TWO user modes:
- ADMIN MODE: For company staff to manage CRM operations
- CLIENT MODE: For customers to view their orders, payments, and issues

================================================================================
2. TECHNOLOGY STACK
================================================================================

FRONTEND:
â”œâ”€â”€ React 18 (UI framework)
â”œâ”€â”€ TypeScript (type-safe JavaScript)
â”œâ”€â”€ Vite (build tool - fast development)
â”œâ”€â”€ Chakra UI v3 (component library)
â”œâ”€â”€ React Router (navigation)
â”œâ”€â”€ Axios (HTTP client)
â””â”€â”€ localStorage (client-side storage)

BACKEND:
â”œâ”€â”€ Django 5.2.7 (Python web framework)
â”œâ”€â”€ Django REST Framework 3.16.1 (API framework)
â”œâ”€â”€ SQLite (development database)
â”œâ”€â”€ Token Authentication (rest_framework.authtoken)
â”œâ”€â”€ CORS Headers (cross-origin support)
â””â”€â”€ Python 3.x

DEVELOPMENT TOOLS:
â”œâ”€â”€ PowerShell (terminal)
â”œâ”€â”€ VS Code (code editor)
â””â”€â”€ Git (version control)

================================================================================
3. ARCHITECTURE PATTERN
================================================================================

Your system follows a LAYERED ARCHITECTURE:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FRONTEND (React)                          â”‚
â”‚  User Interface + State Management + Routing                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ HTTP/REST API (JSON)
                   â”‚ Authentication: Token Header
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  BACKEND (Django)                            â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  HTTP/API LAYER (ViewSets)                       â”‚       â”‚
â”‚  â”‚  - Handle requests/responses                     â”‚       â”‚
â”‚  â”‚  - Validate input                                â”‚       â”‚
â”‚  â”‚  - Authentication & permissions                  â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                   â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  BUSINESS LOGIC LAYER (Services)                 â”‚       â”‚
â”‚  â”‚  - CustomerService, LeadService, DealService     â”‚       â”‚
â”‚  â”‚  - AnalyticsService, AuthService                 â”‚       â”‚
â”‚  â”‚  - Pure business logic, no HTTP knowledge        â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                   â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  SERIALIZATION LAYER (Serializers)               â”‚       â”‚
â”‚  â”‚  - Convert Python objects â†” JSON                 â”‚       â”‚
â”‚  â”‚  - Input validation                              â”‚       â”‚
â”‚  â”‚  - Data transformation                           â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                   â”‚                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  DATABASE LAYER (Models/ORM)                     â”‚       â”‚
â”‚  â”‚  - Data models (User, Customer, Lead, Deal)      â”‚       â”‚
â”‚  â”‚  - Database queries                              â”‚       â”‚
â”‚  â”‚  - Relationships & constraints                   â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚  SQLite DB     â”‚
           â”‚  (db.sqlite3)  â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
4. DATA FLOW - HOW A REQUEST WORKS
================================================================================

Let's trace what happens when a user views the customer list:

STEP 1: USER ACTION (Frontend)
-------------------------------
User navigates to /customers
â†“
React Router loads CustomersPage component
â†“
CustomersPage calls useCustomers() hook
â†“
Hook calls customerService.getAll()

STEP 2: API REQUEST (Frontend Service)
---------------------------------------
customerService.getAll() does:
  - Gets API endpoint: API_CONFIG.ENDPOINTS.CUSTOMERS.LIST
  - Calls api.get('/api/customers/')
  - api (apiClient) intercepts request
  - Adds Authorization header: "Token abc123xyz..."
  - Sends HTTP GET to: http://127.0.0.1:8000/api/customers/

STEP 3: BACKEND RECEIVES REQUEST
---------------------------------
Django receives: GET /api/customers/
â†“
URLs routing (crmApp/urls.py):
  router matches 'customers' â†’ CustomerViewSet
â†“
Middleware processes request:
  - CORS headers added
  - Security checks
â†“
Token authentication extracts user from token
â†“
CustomerViewSet.list() is called

STEP 4: BACKEND PROCESSES (ViewSet â†’ Service â†’ Model)
------------------------------------------------------
CustomerViewSet.list():
  - Checks user permissions (IsAuthenticated)
  - Gets user's organization
  - Filters: Customer.objects.filter(organization=user_org)
  - Applies pagination (25 per page)
  - Serializes data: CustomerListSerializer(customers, many=True)
  - Returns Response with JSON

STEP 5: RESPONSE TRAVELS BACK
------------------------------
Django sends HTTP response:
{
  "count": 150,
  "next": "http://127.0.0.1:8000/api/customers/?page=2",
  "previous": null,
  "results": [
    {
      "id": 1,
      "name": "John Doe",
      "email": "john@example.com",
      "status": "active",
      "assigned_to_name": "Sarah Manager",
      ...
    },
    ...
  ]
}
â†“
Frontend apiClient receives response
â†“
Logs in console (development mode)
â†“
Returns data to customerService.getAll()

STEP 6: FRONTEND UPDATES UI
----------------------------
useCustomers hook receives data
â†“
Updates component state with customers
â†“
React re-renders CustomersPage
â†“
CustomerTable displays data in table
â†“
User sees customer list!

================================================================================
5. AUTHENTICATION & SECURITY FLOW
================================================================================

HOW LOGIN WORKS:
----------------

1. USER ENTERS CREDENTIALS
   User types username/email + password in LoginForm

2. FRONTEND SENDS LOGIN REQUEST
   LoginForm calls: authService.login({ username, password })
   â†“
   POST /api/auth/login/
   Body: { "username": "john@example.com", "password": "secret123" }

3. BACKEND VALIDATES
   LoginViewSet receives request
   â†“
   LoginSerializer validates:
     - Checks if username contains '@' (email) or is a username
     - If email: authenticates with email directly
     - If username: looks up user by username, gets email, then authenticates
   â†“
   Django's authenticate() checks password hash
   â†“
   If valid:
     - Gets or creates Token for user
     - Returns: { "token": "abc123...", "user": {...}, "message": "..." }

4. FRONTEND STORES AUTH DATA
   authService.login() receives response
   â†“
   Stores in localStorage:
     - authToken: "abc123..."
     - user: JSON string of user object
   â†“
   Redirects to /dashboard

5. SUBSEQUENT REQUESTS USE TOKEN
   Every API request includes:
   Headers: { "Authorization": "Token abc123..." }
   â†“
   Backend validates token
   â†“
   Attaches user to request object
   â†“
   ViewSet can access request.user

TOKEN AUTHENTICATION:
---------------------
â”œâ”€â”€ Token stored in localStorage (frontend)
â”œâ”€â”€ Sent in Authorization header: "Token <key>"
â”œâ”€â”€ Backend validates via TokenAuthentication
â”œâ”€â”€ Token never expires (until logout)
â””â”€â”€ Logout deletes token from localStorage

SECURITY FEATURES:
------------------
âœ“ Passwords hashed with Django's PBKDF2
âœ“ CSRF protection disabled (using Token auth)
âœ“ CORS configured for specific origins
âœ“ Token authentication on all protected endpoints
âœ“ Organization-level data isolation (multi-tenancy)
âœ“ 401 handling redirects to login automatically

================================================================================
6. FRONTEND ARCHITECTURE
================================================================================

FOLDER STRUCTURE:
-----------------
web-frontend/src/
â”œâ”€â”€ components/          # Reusable UI components
â”‚   â”œâ”€â”€ auth/           # Login, Signup forms
â”‚   â”œâ”€â”€ common/         # Card, IconBox, etc.
â”‚   â”œâ”€â”€ customers/      # Customer-specific components
â”‚   â”œâ”€â”€ deals/          # Deal-specific components
â”‚   â”œâ”€â”€ dashboard/      # Dashboard components
â”‚   â”œâ”€â”€ leads/          # Lead components
â”‚   â””â”€â”€ ui/             # Chakra UI components
â”‚
â”œâ”€â”€ pages/              # Route pages
â”‚   â”œâ”€â”€ LoginPage.tsx
â”‚   â”œâ”€â”€ DashboardPage.tsx
â”‚   â”œâ”€â”€ CustomersPage.tsx
â”‚   â”œâ”€â”€ DealsPage.tsx
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ services/           # API communication layer
â”‚   â”œâ”€â”€ auth.service.ts
â”‚   â”œâ”€â”€ customer.service.ts
â”‚   â”œâ”€â”€ deal.service.ts
â”‚   â””â”€â”€ analytics.service.ts
â”‚
â”œâ”€â”€ hooks/              # Custom React hooks
â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”œâ”€â”€ useCustomers.ts
â”‚   â””â”€â”€ useDeals.ts
â”‚
â”œâ”€â”€ config/             # Configuration
â”‚   â”œâ”€â”€ api.config.ts   # API endpoints
â”‚   â”œâ”€â”€ constants.ts    # App constants
â”‚   â””â”€â”€ index.ts        # Consolidated exports
â”‚
â”œâ”€â”€ types/              # TypeScript types
â”‚   â”œâ”€â”€ index.ts        # Main types
â”‚   â”œâ”€â”€ auth.types.ts
â”‚   â”œâ”€â”€ lead.types.ts
â”‚   â””â”€â”€ ...
â”‚
â”œâ”€â”€ utils/              # Utility functions
â”‚   â”œâ”€â”€ format.ts       # Formatting helpers
â”‚   â”œâ”€â”€ validation.ts   # Validation functions
â”‚   â””â”€â”€ errorHandling.ts # Error handling
â”‚
â”œâ”€â”€ lib/                # Third-party integrations
â”‚   â””â”€â”€ apiClient.ts    # Axios configuration
â”‚
â”œâ”€â”€ theme/              # Chakra UI theme
â”‚   â””â”€â”€ system.ts
â”‚
â””â”€â”€ App.tsx             # Main app component

KEY FRONTEND PATTERNS:
----------------------

1. SERVICES PATTERN (API Layer)
   - Services handle all API calls
   - Return promises with typed data
   - No UI logic, pure data fetching
   
   Example:
   class CustomerService {
     async getAll() {
       return api.get(ENDPOINTS.CUSTOMERS.LIST);
     }
   }

2. HOOKS PATTERN (State Management)
   - Custom hooks manage component state
   - Handle loading, error states
   - Fetch data on mount
   
   Example:
   function useCustomers() {
     const [customers, setCustomers] = useState([]);
     const [loading, setLoading] = useState(true);
     
     useEffect(() => {
       customerService.getAll()
         .then(setCustomers)
         .finally(() => setLoading(false));
     }, []);
     
     return { customers, loading };
   }

3. COMPONENT COMPOSITION
   - Small, focused components
   - Props for data and callbacks
   - Barrel exports for clean imports
   
   Example:
   export { LoginForm, SignupForm } from './auth';
   import { LoginForm } from '@/components';

================================================================================
7. BACKEND ARCHITECTURE
================================================================================

FOLDER STRUCTURE:
-----------------
shared-backend/crmApp/
â”œâ”€â”€ models/                  # Database models
â”‚   â”œâ”€â”€ auth.py             # User, UserProfile
â”‚   â”œâ”€â”€ organization.py     # Organization, UserOrganization
â”‚   â”œâ”€â”€ customer.py         # Customer model
â”‚   â”œâ”€â”€ lead.py             # Lead model
â”‚   â”œâ”€â”€ deal.py             # Deal, Pipeline
â”‚   â””â”€â”€ base.py             # Base mixins
â”‚
â”œâ”€â”€ serializers/            # API serialization
â”‚   â”œâ”€â”€ auth.py             # User serializers
â”‚   â”œâ”€â”€ customer.py         # Customer serializers
â”‚   â”œâ”€â”€ lead.py             # Lead serializers
â”‚   â””â”€â”€ deal.py             # Deal serializers
â”‚
â”œâ”€â”€ viewsets/               # API endpoints
â”‚   â”œâ”€â”€ auth.py             # Authentication endpoints
â”‚   â”œâ”€â”€ customer.py         # Customer CRUD
â”‚   â”œâ”€â”€ lead.py             # Lead management
â”‚   â”œâ”€â”€ deal.py             # Deal pipeline
â”‚   â””â”€â”€ analytics.py        # Analytics endpoints
â”‚
â”œâ”€â”€ services/               # Business logic
â”‚   â”œâ”€â”€ auth_service.py
â”‚   â”œâ”€â”€ customer_service.py
â”‚   â”œâ”€â”€ lead_service.py
â”‚   â”œâ”€â”€ deal_service.py
â”‚   â””â”€â”€ analytics_service.py
â”‚
â”œâ”€â”€ utils.py                # Utility functions
â”œâ”€â”€ validators.py           # Custom validators
â”œâ”€â”€ permissions.py          # Permission classes
â”œâ”€â”€ mixins.py               # Reusable ViewSet mixins
â”œâ”€â”€ error_handler.py        # Error handling
â””â”€â”€ urls.py                 # URL routing

KEY BACKEND PATTERNS:
---------------------

1. VIEWSET PATTERN (HTTP Layer)
   - Handles HTTP requests/responses
   - Authentication & permissions
   - Delegates to services
   
   class CustomerViewSet(viewsets.ModelViewSet):
       queryset = Customer.objects.all()
       serializer_class = CustomerSerializer
       permission_classes = [IsAuthenticated]
       
       def list(self, request):
           customers = self.get_queryset()
           serializer = self.get_serializer(customers, many=True)
           return Response(serializer.data)

2. SERVICE LAYER PATTERN (Business Logic)
   - Pure business logic
   - No HTTP knowledge
   - Reusable across views
   
   class CustomerService:
       @staticmethod
       def create_customer(data, organization, user):
           customer = Customer.objects.create(
               organization=organization,
               created_by=user,
               **data
           )
           return customer

3. SERIALIZER PATTERN (Data Transformation)
   - Converts models â†” JSON
   - Input validation
   - Nested relationships
   
   class CustomerSerializer(serializers.ModelSerializer):
       assigned_to_name = serializers.CharField(
           source='assigned_to.name',
           read_only=True
       )
       
       class Meta:
           model = Customer
           fields = ['id', 'name', 'email', 'assigned_to_name']

4. MODEL PATTERN (Data Layer)
   - Database tables
   - Relationships
   - Business logic methods
   
   class Customer(TimestampedModel, ContactInfoMixin):
       organization = models.ForeignKey(Organization)
       name = models.CharField(max_length=255)
       email = models.EmailField()
       
       @property
       def full_name(self):
           return f"{self.first_name} {self.last_name}"

================================================================================
8. DATABASE SCHEMA
================================================================================

MAIN TABLES:
------------

1. USERS
   - id (primary key)
   - username (unique)
   - email (unique) â† used for login
   - password (hashed)
   - first_name, last_name
   - is_active, is_staff
   - created_at, updated_at

2. AUTH_TOKENS
   - key (token string)
   - user_id (foreign key â†’ users)
   - created (timestamp)

3. ORGANIZATIONS
   - id
   - name
   - slug
   - created_at, updated_at

4. USER_PROFILES
   - id
   - user_id â†’ users
   - organization_id â†’ organizations
   - profile_type (vendor, employee, customer)
   - status

5. CUSTOMERS
   - id
   - organization_id â†’ organizations
   - user_id â†’ users (optional, for portal access)
   - name
   - email, phone
   - status (active, inactive, prospect, vip)
   - assigned_to_id â†’ employees
   - created_at, updated_at

6. LEADS
   - id
   - organization_id â†’ organizations
   - first_name, last_name, email, phone
   - company, job_title
   - source (website, referral, social_media, etc.)
   - status (new, contacted, qualified, unqualified)
   - score (0-100, auto-calculated)
   - assigned_to_id â†’ employees
   - converted_to_customer_id â†’ customers

7. DEALS
   - id
   - organization_id â†’ organizations
   - customer_id â†’ customers
   - title
   - value (decimal)
   - stage (lead, qualified, proposal, negotiation)
   - probability (0-100)
   - expected_close_date
   - assigned_to_id â†’ employees
   - is_won, is_lost, is_closed

8. PIPELINES
   - id
   - organization_id
   - name
   - is_default

9. PIPELINE_STAGES
   - id
   - pipeline_id â†’ pipelines
   - name
   - order
   - probability

10. EMPLOYEES
    - id
    - organization_id
    - user_id â†’ users
    - department
    - position
    - hire_date

RELATIONSHIPS:
--------------
User â”€â”€1:manyâ”€â”€ UserProfiles â”€â”€many:1â”€â”€ Organization
User â”€â”€1:1â”€â”€â”€â”€â”€â”€â†’ Token
Organization â”€â”€1:manyâ”€â”€ Customers
Organization â”€â”€1:manyâ”€â”€ Leads
Organization â”€â”€1:manyâ”€â”€ Deals
Customer â”€â”€1:manyâ”€â”€â”€â”€â”€â†’ Deals
Employee â”€â”€1:manyâ”€â”€â”€â”€â”€â†’ Customers (assigned)
Employee â”€â”€1:manyâ”€â”€â”€â”€â”€â†’ Leads (assigned)
Employee â”€â”€1:manyâ”€â”€â”€â”€â”€â†’ Deals (assigned)
Lead â”€â”€1:1â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Customer (when converted)

================================================================================
9. API STRUCTURE
================================================================================

BASE URL: http://127.0.0.1:8000/api/

AUTHENTICATION ENDPOINTS:
-------------------------
POST   /api/users/                    Register new user
POST   /api/auth/login/               Login (get token)
POST   /api/auth/logout/              Logout (invalidate token)
GET    /api/users/me/                 Get current user profile
PUT    /api/users/update_profile/    Update current user

CUSTOMER ENDPOINTS:
-------------------
GET    /api/customers/               List all customers (paginated)
POST   /api/customers/               Create customer
GET    /api/customers/{id}/          Get customer detail
PUT    /api/customers/{id}/          Update customer
DELETE /api/customers/{id}/          Delete customer
GET    /api/customers/stats/         Customer statistics

LEAD ENDPOINTS:
---------------
GET    /api/leads/                   List all leads
POST   /api/leads/                   Create lead
GET    /api/leads/{id}/              Get lead detail
PUT    /api/leads/{id}/              Update lead
DELETE /api/leads/{id}/              Delete lead
POST   /api/leads/{id}/convert/     Convert lead to customer
POST   /api/leads/{id}/qualify/     Mark lead as qualified

DEAL ENDPOINTS:
---------------
GET    /api/deals/                   List all deals
POST   /api/deals/                   Create deal
GET    /api/deals/{id}/              Get deal detail
PUT    /api/deals/{id}/              Update deal
DELETE /api/deals/{id}/              Delete deal
POST   /api/deals/{id}/move_stage/  Move to different stage
POST   /api/deals/{id}/mark_won/    Mark deal as won
POST   /api/deals/{id}/mark_lost/   Mark deal as lost

ANALYTICS ENDPOINTS:
--------------------
GET    /api/analytics/dashboard/             Dashboard stats
GET    /api/analytics/sales_funnel/          Sales funnel metrics
GET    /api/analytics/revenue_by_period/     Revenue analytics
GET    /api/analytics/employee_performance/  Employee metrics

ORGANIZATION ENDPOINTS:
-----------------------
GET    /api/organizations/                   List organizations
GET    /api/organizations/my_organizations/  User's organizations
POST   /api/organizations/{id}/add_member/   Add team member

REQUEST FORMAT:
---------------
Headers:
  Content-Type: application/json
  Authorization: Token abc123xyz...

Body (JSON):
  {
    "name": "John Doe",
    "email": "john@example.com",
    "status": "active"
  }

RESPONSE FORMAT:
----------------
Success (200):
  {
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com",
    "created_at": "2025-11-06T12:00:00Z"
  }

Paginated (200):
  {
    "count": 150,
    "next": "http://127.0.0.1:8000/api/customers/?page=2",
    "previous": null,
    "results": [ {...}, {...} ]
  }

Error (400):
  {
    "error": true,
    "message": "Validation error",
    "errors": {
      "email": ["This field is required"]
    }
  }

Error (401):
  {
    "detail": "Authentication credentials were not provided."
  }

================================================================================
10. KEY FEATURES
================================================================================

1. MULTI-TENANCY
   - Each organization has isolated data
   - Users can belong to multiple organizations
   - All data filtered by organization automatically

2. ROLE-BASED ACCESS CONTROL (RBAC)
   - Roles: Owner, Admin, Manager, Employee, Client
   - Permissions for create, read, update, delete
   - Custom permission checks in viewsets

3. LEAD SCORING
   - Automatic scoring (0-100) based on:
     â€¢ Email provided: +10
     â€¢ Phone provided: +10
     â€¢ Company name: +15
     â€¢ Job title: +10
     â€¢ Source (referral=25, partner=20, website=15)
     â€¢ Estimated value (>$100k=20, >$50k=15, >$10k=10)

4. DEAL PIPELINE
   - Customizable stages
   - Probability tracking
   - Expected close dates
   - Revenue forecasting

5. ANALYTICS
   - Customer growth metrics
   - Lead conversion rates
   - Deal win rates
   - Revenue by period
   - Employee performance
   - Sales funnel visualization

6. DUAL MODE INTERFACE
   - Admin mode: Full CRM features
   - Client mode: Customer portal (orders, payments, issues)

================================================================================
11. HOW EVERYTHING WORKS TOGETHER
================================================================================

COMPLETE EXAMPLE: Creating a New Customer
------------------------------------------

1. USER ACTION (Frontend)
   User clicks "Add Customer" button on /customers page
   â†“
   Modal opens with form (CreateCustomerForm component)
   â†“
   User fills:
     - Name: "Acme Corp"
     - Email: "contact@acme.com"
     - Status: "active"
   â†“
   User clicks "Save"

2. FORM SUBMISSION (Frontend)
   Form validates using validation.ts:
     - Email format check
     - Required fields
   â†“
   If valid:
     const newCustomer = {
       name: "Acme Corp",
       email: "contact@acme.com",
       status: "active"
     };
     
     customerService.create(newCustomer);

3. API CALL (Frontend Service)
   customerService.create() does:
     POST /api/customers/
     Headers: {
       Authorization: "Token abc123...",
       Content-Type: "application/json"
     }
     Body: { name, email, status }

4. BACKEND RECEIVES (Django)
   Request hits CustomerViewSet.create()
   â†“
   Authentication: Token validated â†’ request.user set
   â†“
   Permission check: IsAuthenticated passes
   â†“
   Get serializer: CustomerCreateSerializer
   â†“
   Validate data:
     - Email format
     - Required fields
     - Unique constraints

5. BUSINESS LOGIC (Service Layer)
   ViewSet calls: CustomerService.create_customer()
   â†“
   Service adds:
     - organization_id (from request.user)
     - created_by (from request.user)
     - code (auto-generated: CUST-001)
     - created_at (timestamp)
   â†“
   Creates database record:
     Customer.objects.create(
       organization=user.organization,
       name="Acme Corp",
       email="contact@acme.com",
       status="active",
       code="CUST-001",
       created_by=user
     )

6. DATABASE (SQLite)
   INSERT INTO customers (
     organization_id, name, email, status,
     code, created_by_id, created_at
   ) VALUES (1, 'Acme Corp', 'contact@acme.com', 
     'active', 'CUST-001', 5, '2025-11-06 12:00:00');
   â†“
   Returns customer with id=123

7. RESPONSE (Backend)
   Serialize customer: CustomerSerializer(customer)
   â†“
   Return Response:
     {
       "id": 123,
       "name": "Acme Corp",
       "email": "contact@acme.com",
       "status": "active",
       "code": "CUST-001",
       "created_at": "2025-11-06T12:00:00Z",
       "assigned_to_name": null
     }

8. FRONTEND UPDATE
   customerService.create() resolves with data
   â†“
   Component updates state:
     setCustomers([...customers, newCustomer]);
   â†“
   React re-renders CustomersPage
   â†“
   New customer appears in table!
   â†“
   Success toast: "Customer created successfully"

9. SIDEBAR EFFECT
   Meanwhile, analytics are updated:
   - Total customers count increases
   - Growth percentage recalculated
   - Dashboard stats refresh on next visit

================================================================================
CRITICAL DESIGN DECISIONS
================================================================================

1. WHY TOKEN AUTHENTICATION (not JWT)?
   - Simpler to implement
   - No token expiration to handle
   - Easier debugging (tokens in database)
   - Sufficient for this use case

2. WHY ORGANIZATION-BASED MULTI-TENANCY?
   - Each company has isolated data
   - Prevents data leaks between organizations
   - Scalable for SaaS deployment

3. WHY SERVICE LAYER?
   - Separates business logic from HTTP
   - Reusable in management commands, tasks, tests
   - Easier to maintain and test

4. WHY SQLITE IN DEVELOPMENT?
   - No setup required
   - Fast for development
   - Easy to reset (just delete file)
   - Note: Should use PostgreSQL in production

5. WHY REACT + DJANGO (not monolith)?
   - Frontend and backend can scale independently
   - Better developer experience
   - Modern SPA user experience
   - API can serve mobile apps later

================================================================================
COMMON OPERATIONS
================================================================================

STARTING THE SYSTEM:
--------------------
Terminal 1 (Backend):
  cd shared-backend
  python manage.py runserver
  â†’ Runs on http://127.0.0.1:8000

Terminal 2 (Frontend):
  cd web-frontend
  npm run dev
  â†’ Runs on http://localhost:5173

CREATING A NEW USER:
--------------------
1. Go to http://localhost:5173/signup
2. Fill form (username, email, password, etc.)
3. Submit â†’ Creates user + organization + token
4. Auto-login â†’ Redirected to dashboard

ADDING AN API ENDPOINT:
-----------------------
1. Add method to ViewSet:
   @action(detail=True, methods=['post'])
   def activate(self, request, pk=None):
       ...

2. Update frontend API config:
   CUSTOMERS: {
     ACTIVATE: (id) => `/customers/${id}/activate/`
   }

3. Call from frontend:
   customerService.activate(customerId);

DEBUGGING:
----------
Frontend:
  - Check browser console for API logs
  - Check Network tab for requests/responses
  - Look for "ğŸš€ API Request" and "âœ… API Response" logs

Backend:
  - Check terminal running `python manage.py runserver`
  - Look for [DATE TIME] "GET /api/customers/ HTTP/1.1" 200 1234
  - Add print() statements in viewsets/services

================================================================================
SUMMARY
================================================================================

Your CRM system is:

âœ“ A FULL-STACK application with React frontend + Django backend
âœ“ Using TOKEN AUTHENTICATION for secure API access
âœ“ Following LAYERED ARCHITECTURE for clean code organization
âœ“ Supporting MULTI-TENANCY with organization-based data isolation
âœ“ Using SERVICE LAYER for reusable business logic
âœ“ Providing REST API with 60+ endpoints
âœ“ Managing Customers, Leads, Deals, Employees, Analytics
âœ“ Supporting both ADMIN and CLIENT modes

The data flows:
  User â†’ Component â†’ Hook â†’ Service â†’ API Client â†’ HTTP Request
  â†’ Django â†’ ViewSet â†’ Service â†’ Model â†’ Database
  â†’ Model â†’ Serializer â†’ Response â†’ HTTP Response
  â†’ API Client â†’ Service â†’ Hook â†’ Component â†’ UI Update

Everything is connected through well-defined layers with clear responsibilities!

================================================================================
END OF GUIDE
================================================================================
